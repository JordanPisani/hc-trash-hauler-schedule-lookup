import{C as n,E as l,G as x,M as j,ap as b,aq as D,ar as R,h as E,m as T,j as G,e as S}from"./index.b4c7b16d.js";var M=Object.defineProperty,F=Object.defineProperties,N=Object.getOwnPropertyDescriptors,I=Object.getOwnPropertySymbols,Z=Object.prototype.hasOwnProperty,C=Object.prototype.propertyIsEnumerable,w=(e,t,r)=>t in e?M(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r,L=(e,t)=>{for(var r in t||(t={}))Z.call(t,r)&&w(e,r,t[r]);if(I)for(var r of I(t))C.call(t,r)&&w(e,r,t[r]);return e},z=(e,t)=>F(e,N(t));let _=class extends D{};n([l()],_.prototype,"events",void 0),n([l()],_.prototype,"strings",void 0),_=n([x("esri.rest.support.DirectionsFeature")],_);const $=_;let a=class extends R{constructor(e){super(e),this.extent=null,this.features=null,this.geometryType="polyline",this.routeId=null,this.routeName=null,this.totalDriveTime=null,this.totalLength=null,this.totalTime=null}readFeatures(e,t){var r;if(!e)return[];const y=(r=t.summary.envelope.spatialReference)!=null?r:t.spatialReference,d=y&&E.fromJSON(y);return e.map(c=>{var p,i;const v=this._decompressGeometry(c.compressedGeometry),g=new T(z(L({},v),{spatialReference:d})),s=(p=(i=c.events)==null?void 0:i.map(f=>{const{arriveTimeUTC:O,ETA:P,point:{x:o,y:u,z:m},strings:h}=f;return new $({geometry:new G({x:o,y:u,z:m,hasZ:m!==void 0,spatialReference:d}),attributes:{ETA:P,arriveTimeUTC:O},strings:h})}))!=null?p:[];return new $({attributes:c.attributes,events:s,geometry:g,strings:c.strings})})}get mergedGeometry(){if(!this.features)return null;const e=this.features.map(({geometry:r})=>S(r)),t=this.get("extent.spatialReference");return this._mergePolylinesToSinglePath(e,t)}get strings(){return this.features.map(({strings:e})=>e)}_decompressGeometry(e){let t=0,r=0,y=0,d=0;const c=[];let p,i,v,g,s,f,O,P,o=0,u=0,m=0;if(s=e.match(/((\+|\-)[^\+\-\|]+|\|)/g),s||(s=[]),parseInt(s[o],32)===0){o=2;const h=parseInt(s[o],32);o++,f=parseInt(s[o],32),o++,1&h&&(u=s.indexOf("|")+1,O=parseInt(s[u],32),u++),2&h&&(m=s.indexOf("|",u)+1,P=parseInt(s[m],32),m++)}else f=parseInt(s[o],32),o++;for(;o<s.length&&s[o]!=="|";){p=parseInt(s[o],32)+t,o++,t=p,i=parseInt(s[o],32)+r,o++,r=i;const h=[p/f,i/f];u&&(g=parseInt(s[u],32)+y,u++,y=g,h.push(g/O)),m&&(v=parseInt(s[m],32)+d,m++,d=v,h.push(v/P)),c.push(h)}return{paths:[c],hasZ:u>0,hasM:m>0}}_mergePolylinesToSinglePath(e,t){if(e.length===0)return new T({spatialReference:t});const r=[];for(const p of e)for(const i of p.paths)r.push(...i);const y=[];r.forEach((p,i)=>{i!==0&&p[0]===r[i-1][0]&&p[1]===r[i-1][1]||y.push(p)});const{hasM:d,hasZ:c}=e[0];return new T({hasM:d,hasZ:c,paths:[y],spatialReference:t})}};n([l({type:j,json:{read:{source:"summary.envelope"}}})],a.prototype,"extent",void 0),n([l()],a.prototype,"features",void 0),n([b("features")],a.prototype,"readFeatures",null),n([l()],a.prototype,"geometryType",void 0),n([l({readOnly:!0})],a.prototype,"mergedGeometry",null),n([l()],a.prototype,"routeId",void 0),n([l()],a.prototype,"routeName",void 0),n([l({value:null,readOnly:!0})],a.prototype,"strings",null),n([l({json:{read:{source:"summary.totalDriveTime"}}})],a.prototype,"totalDriveTime",void 0),n([l({json:{read:{source:"summary.totalLength"}}})],a.prototype,"totalLength",void 0),n([l({json:{read:{source:"summary.totalTime"}}})],a.prototype,"totalTime",void 0),a=n([x("esri.rest.support.DirectionsFeatureSet")],a);const U=a;export{U as c};
