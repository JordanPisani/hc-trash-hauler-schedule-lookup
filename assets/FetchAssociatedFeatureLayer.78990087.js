import{t as i,r as d,_ as p,J as m,aJ as u,ez as h,ah as g,af as S}from"./index.b4c7b16d.js";const v={attachment:{supportsContentType:!1,supportsExifInfo:!1,supportsKeywords:!1,supportsName:!1,supportsSize:!1},data:{isVersioned:!1,supportsAttachment:!1,supportsM:!1,supportsZ:!1},editing:{supportsDeleteByAnonymous:!1,supportsDeleteByOthers:!1,supportsGeometryUpdate:!1,supportsGlobalId:!1,supportsReturnServiceEditsInSourceSpatialReference:!1,supportsRollbackOnFailure:!1,supportsUpdateByAnonymous:!1,supportsUpdateByOthers:!1,supportsUpdateWithoutM:!1,supportsUploadWithItemId:!1},metadata:{supportsAdvancedFieldProperties:!1},operations:{supportsCalculate:!1,supportsTruncate:!1,supportsValidateSql:!1,supportsAdd:!1,supportsDelete:!1,supportsEditing:!1,supportsChangeTracking:!1,supportsQuery:!1,supportsQueryAttachments:!1,supportsResizeAttachments:!1,supportsSync:!1,supportsUpdate:!1,supportsExceedsLimitStatistics:!1},queryRelated:{supportsCount:!1,supportsOrderBy:!1,supportsPagination:!1},query:{maxRecordCount:0,maxRecordCountFactor:0,standardMaxRecordCount:0,supportsCacheHint:!1,supportsCentroid:!1,supportsCompactGeometry:!1,supportsDefaultSpatialReference:!1,supportsDisjointSpatialRelationship:!1,supportsDistance:!1,supportsDistinct:!1,supportsExtent:!1,supportsFormatPBF:!1,supportsGeometryProperties:!1,supportsHavingClause:!1,supportsHistoricMoment:!1,supportsMaxRecordCountFactor:!1,supportsOrderBy:!1,supportsPagination:!1,supportsPercentileStatistics:!1,supportsQuantization:!1,supportsQuantizationEditMode:!1,supportsQueryByOthers:!1,supportsQueryGeometry:!1,supportsResultType:!1,supportsSqlExpression:!1,supportsStandardizedQueriesOnly:!1,supportsTopFeaturesQuery:!1,supportsSpatialAggregationStatistics:!1,supportedSpatialAggregationStatistics:{envelope:!1,centroid:!1,convexHull:!1},supportsStatistics:!1,tileMaxRecordCount:0}};class P{constructor(s,t,e,r){this.parsedUrl=s,this.portalItem=t,this.apiKey=e,this.signal=r,this.rootDocument=null;const a=this.parsedUrl.path.match(/^(.*)\/SceneServer\/layers\/([\d]*)\/?$/i);a&&(this.urlParts={root:a[1],layerId:parseInt(a[2],10)})}async fetch(){var s;if(!this.urlParts)return null;const t=(s=this.portalItem)!=null?s:await this._portalItemFromServiceItemId();if(i(t))return this._loadFromUrl();const e=await this._findAndLoadRelatedPortalItem(t);return i(e)?null:this._loadFeatureLayerFromPortalItem(e)}async fetchPortalItem(){var s;if(!this.urlParts)return null;const t=(s=this.portalItem)!=null?s:await this._portalItemFromServiceItemId();return i(t)?null:this._findAndLoadRelatedPortalItem(t)}async _fetchRootDocument(){if(d(this.rootDocument))return this.rootDocument;if(i(this.urlParts))return this.rootDocument={},{};const s={query:{f:"json",token:this.apiKey},responseType:"json",signal:this.signal},t=`${this.urlParts.root}/SceneServer`;try{const e=await p(t,s);this.rootDocument=e.data}catch{this.rootDocument={}}return this.rootDocument}async _fetchServiceOwningPortalUrl(){var s;const t=(s=m)==null?void 0:s.findServerInfo(this.parsedUrl.path);if(t!=null&&t.owningSystemUrl)return t.owningSystemUrl;const e=this.parsedUrl.path.replace(/(.*\/rest)\/.*/i,"$1")+"/info";try{const r=(await p(e,{query:{f:"json"},responseType:"json",signal:this.signal})).data.owningSystemUrl;if(r)return r}catch(r){u(r)}return null}async _findAndLoadRelatedPortalItem(s){try{return(await s.fetchRelatedItems({relationshipType:"Service2Service",direction:"reverse"},{signal:this.signal})).find(t=>t.type==="Feature Service")||null}catch(t){return u(t),null}}async _loadFeatureLayerFromPortalItem(s){await s.load({signal:this.signal});const t=await this._findMatchingAssociatedSublayerUrl(s.url);return new h({url:t,portalItem:s}).load({signal:this.signal})}async _loadFromUrl(){const s=await this._findMatchingAssociatedSublayerUrl(`${this.urlParts.root}/FeatureServer`);return new h({url:s}).load({signal:this.signal})}async _findMatchingAssociatedSublayerUrl(s){const t=s.replace(/^(.*FeatureServer)(\/[\d]*\/?)?$/i,"$1"),e={query:{f:"json"},responseType:"json",authMode:"no-prompt",signal:this.signal},r=this.urlParts.layerId,a=this._fetchRootDocument(),y=p(t,e),[c,f]=await Promise.all([y,a]),n=f&&f.layers,o=c.data&&c.data.layers;if(!Array.isArray(o))throw new Error("expected layers array");if(Array.isArray(n)){for(let l=0;l<Math.min(n.length,o.length);l++)if(n[l].id===r)return`${t}/${o[l].id}`}else if(r<o.length)return`${t}/${o[r].id}`;throw new Error("could not find matching associated sublayer")}async _portalItemFromServiceItemId(){const s=(await this._fetchRootDocument()).serviceItemId;if(!s)return null;const t=new g({id:s,apiKey:this.apiKey}),e=await this._fetchServiceOwningPortalUrl();d(e)&&(t.portal=new S({url:e}));try{return t.load({signal:this.signal})}catch(r){return u(r),null}}}export{P as l,v as t};
